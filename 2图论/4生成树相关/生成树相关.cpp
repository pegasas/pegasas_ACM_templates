最小生成树的性质：
1.切割性质：若所有边权值都不相同。设S是既非空集也非全集的V的子集，边e是满足顶点分别在S和V-S集合中的所有边中权值最小的一个，则G中的所有最小生成树都包含e。
证明：设<u,v>是连接S和V-S集合所有边权最短的边。若存在MST不包含<u,v>，连接<u,v>，形成一个环，环上至少有一条不是<u,v>的边能够连接集合V和S-V，其权值比<u,v>大，用<u,v>替换后，MST变小，矛盾！因此所有MST都有<u,v>边。
2.回路性质：若所有边权值都不相同。设C是G中的任意回路，边e是C上权值最大的边，则G中所有的最小生成树都不包含e。
证明：若存在MST包含C环上的最大权值边<u,v>，删除<u,v>后，变成两个连通块S和T，C环上u->v不经过<u,v>边的路径中至少有一条边横跨S和T连通块，用该边替换<u,v>后，MST变小，矛盾！因此所有的MST都没有边<u,v>。
证明思想：1.反证法：先假设存在满足某性质的MST，证明经过替换后MST可以变小 2.替换方式：1）先添边成环，再从环中删边。
2）先删边成块，再从连接两个连通块的边中选一条边加入。

最小生成树的变题
1.增量最小生成树：动态添边，求最小生成树 O(N*Q) N：顶点数、Q：添边数
添加边<u,v>后，找到原MST中u->v路径上的最长边<u',v'>(O(N)),删除两者的较长边，添加较短边即可。
变题：只询问添加新边后，最小生成树是否变化，多组询问 O(N*N+Q)
1.先求原图MST
2.O(n^2)预处理任两点MST路径瓶颈。
3.添边一定是非树边。每次询问比较新边与瓶颈即可判断MST是否变换。

2.最小瓶颈生成树：求最大权值边最小的生成树
结论：最小生成树一定是最小瓶颈生成树。
1.从空图开始，按照权值从小到大依次加入各边（满足不成环），第一次连通时，一定是最小瓶颈生成树。
证明：按照上述方法加边过程中，有一边<u,v>可加入，但并没有加入。最终的生成树设为T1,连接<u,v>，T1中形成一个环，环中一定存在一边的权值不小于<u,v>边的权值，用<u,v>替换该边后，形成数T2。若删除的边是T1中的最长边，则T2的瓶颈<T1的瓶颈，否则T1的瓶颈=T2的瓶颈，因此，T2的瓶颈<=T1的瓶颈，瓶颈不增，因此任意添边得到的生成树瓶颈>=按照可行边从小到大加入得到的生成树的瓶颈。
2.按照可行边从小到大加入得到的生成树得到的恰是最小生成树。
综上，最小生成树一定是最小瓶颈生成树。
注：最小瓶颈生成树不一定是最小生成树。

3.最小瓶颈路：u->v最长边最短的路径
结论：生成树上的任意两点的路径就是这两点的最小瓶颈路。
证明方法与最小瓶颈生成树类似。（反证，换边后结果不增）。
先把u点加入点集S，向S中从小到大加边，直到u，v连通为止，这样操作得到u->v路径的瓶颈最小。（反证）若存在可行边未加入，u，v连通后，加入该边，则环上存在某边权值>=该边权值，替换后，u->v的瓶颈不增，因此按照顺序加边u->v的路径瓶颈最小。

4.次小生成树 O(N^2+M)
结论：次小生成树一定能够由最小生成树替换一条边得到
证明：假设T0是次小生成树，T是最小生成树，任何一边<u,v>属于T0而不属于T，则在T0中删除<u,v>后T0变成两个连通块，在T中一定存在边<u',v'>连接这两个连通块，由Kruscal算法的贪心选择可知，<u',v'>权值比<u,v>小。在T0中连接<u',v'>得到T1。依次删边、加边、删边、加边...直到Tk和T仅差一条边，因为T0>=T1>=T2>=...>=TK>=T,所以TK是次小生成树，且仅与T有一条边不同。故结论成立。
1.求最小生成树上任意两点的瓶颈dp[u][v]---DP O(n^2)
对于所有访问过的点x，当前点u及父节点v，dp[x][u]=max{ dp[x][v],w[u][v] }。
2.对于所有非树边<u,v>若mst'=mst+min(w[u][v]-dp[u][v])。O(m)
//计算mst任意两点间的瓶颈路
vector<int> g[maxn];
int vis[maxn],dp[maxn][maxn];
mem(dp,0);
void dfs(int u,int fa){
    for(int i=0;i<n;i++){
        if(vis[i]) dp[i][u]=dp[u][i]=max(dp[i][fa],d[u][fa]);
    }
    vis[u]=1;
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i];
        if(v!=fa) dfs(v,u);
    }
}
5.若增加已有边的权值（删除已有边<=>增大已有边到正无穷），求最小生成树的变化量（多组询问，不修改） O(mlogm+N^2+Q)
1.先求原图的MST O(mlogm)
2.设MST上任意边的两端点u,v所在连通块（删除该边后形成的两个连通块）通过非树边连接的最短边是best[u][v]。O(n^2)
//计算rt通过非树边到达u子树的所有点中的最短边
mem(dp,INF);
void dfs1(int u,int fa,int rt){
    if(fa!=rt) dp[rt][u]=min(dp[rt][u],ma[rt][u]);
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i];
        if(v==fa) continue;
        dfs(v,u,rt);
        dp[rt][u]=min(dp[rt][u],dp[rt][v]);
    }
}


//对于任意一条边<u,v>调用 dfs2(v,u,u)，得到mst中去掉<u,v>边后，连接两连通块儿的最短边
//<如果fa是u的父节点，则以u及其子树中的任一点为根，重置树，fa的子节点即为原树中不包含u及其子树的所有节点
mem(best,INF);
int dfs2(int u,int fa,int rt){
    int ans=dp[u][rt];
    for(int i=0;u<g[u].size();i++){
        int v=g[u][i];
        if(v==fa) continue;
        ans=min(ans,dfs2(v,u,rt));
    }
    return ans;
}
3.求出best[u][v]后，对于每组询问<u,v>：若<u,v>不是树边，则MST不变，否则比较best[u][v]和变化后的<u,v>树边值，即可判断MST是否变化。O(1)

6.若减少已有边的权值，求最小生成树的变化量（多组询问，不修改）O(MlogM+N^2+Q)
1.先求原图的MST O(mlogm)
2.求MST上任意两点的瓶颈dp[u][v] O(n^2)
3.每组询问<u,v>->w0：1）树边：mst'=mst-w[u][v]+w0 2）非树边：mst'=min(mst,mst-dp[u][v]+w0) O(1
