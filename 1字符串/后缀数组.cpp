构造后缀数组——SA

先定义一些变量的含义

Str ：需要处理的字符串(长度为Len)
Suffix[i] ：Str下标为i ~ Len的连续子串(即后缀)
Rank[i] : Suffix[i]在所有后缀中的排名
SA[i] : 满足Suffix[SA[1]] < Suffix[SA[2]] …… < Suffix[SA[Len]],即排名为i的后缀为Suffix[SA[i]] (与Rank是互逆运算)
好，来形象的理解一下
这就是Rank和SA
后缀数组指的就是这个SA[i],有了它，我们就可以实现一些很强大的功能(如不相同子串个数、连续重复子串等)。如何快速的到它，便成为了这个算法的关键。而SA和Rank是互逆的，只要求出任意一个，另一个就可以O(Len)得到。
现在比较主流的算法有两种，倍增和DC3，在这里，就主要讲一下稍微慢一些，但比较好实现以及理解的倍增算法(虽说慢，但也是O(Len logLen))的。

进入正题——倍增算法

倍增算法的主要思想 ：对于一个后缀Suffix[i],如果想直接得到Rank比较困难，但是我们可以对每个字符开始的长度为2k的字符串求出排名，k从0开始每次递增1(每递增1就成为一轮)，当2k大于Len时，所得到的序列就是Rank，而SA也就知道了。O(logLen)枚举k
这样做有什么好处呢？
设每一轮得到的序列为rank(注意r是小写，最终后缀排名Rank是大写)。有一个很美妙的性质就出现了！第k轮的rank可由第k - 1轮的rank快速得来!
为什么呢？为了方便描述，设SubStr(i, len)为从第i个字符开始，长度为len的字符串我们可以把第k轮SubStr(i, 2k)看成是一个由SubStr(i, 2k−1)和SubStr(i + 2k−1, 2k−1)拼起来的东西。类似rmq算法，这两个长度而2k−1的字符串是上一轮遇到过的！当然上一轮的rank也知道！那么吧每个这一轮的字符串都转化为这种形式，并且大家都知道字符串的比较是从左往右，左边和右边的大小我们可以用上一轮的rank表示，那么……这不就是一些两位数(也可以视为第一关键字和第二关键字)比较大小吗!再把这些两位数重新排名就是这一轮的rank。
我们用下面这张经典的图理解一下：
就像一个两位数的比较
相信只要理解字符串的比较法则(跟实数差不多)，理解起来并不难。#还有一个细节就是怎么把这些两位数排序？这种位数少的数进行排序毫无疑问的要用一个复杂度为长度*排序数的个数的优美算法——基数排序(对于两位数的数复杂度就是O(Len)的)。
基数排序原理 ： 把数字依次按照由低位到高位依次排序，排序时只看当前位。对于每一位排序时，因为上一位已经是有序的，所以这一位相等或符合大小条件时就不用交换位置，如果不符合大小条件就交换，实现可以用”桶”来做。(叙说起来比较奇怪，看完下面的代码应该更好理解，也可以上网查有关资料)
好了SA和Rank(大写R)到此为止就处理好了。(下面有详解代码！)。但我们发现，只有这两样东西好像没什么用，为了处理重复子串之类的问题，我们就要引入一个表示最长公共前缀的新助手Height数组！

构造最长公共前缀——Height

同样先是定义一些变量

Heigth[i] : 表示Suffix[SA[i]]和Suffix[SA[i - 1]]的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀
H[i] : 等于Height[Rank[i]]，也就是后缀Suffix[i]和它前一名的后缀的最长公共前缀
而两个排名不相邻的最长公共前缀定义为排名在它们之间的Height的最小值。
跟上面一样，先形像的理解一下：
这就是Height

高效地得到Height数组

如果一个一个数按SA中的顺序比较的话复杂度是O(N2)级别的，想要快速的得到Height就需要用到一个关于H数组的性质。
H[i] ≥ H[i - 1] - 1!
如果上面这个性质是对的，那我们可以按照H[1]、H[2]……H[Len]的顺序进行计算，那么复杂度就降为O(N)了！
让我们尝试一下证明这个性质 : 设Suffix[k]是排在Suffix[i - 1]前一名的后缀，则它们的最长公共前缀是H[i - 1]。都去掉第一个字符，就变成Suffix[k + 1]和Suffix[i]。如果H[i - 1] = 0或1,那么H[i] ≥ 0显然成立。否则，H[i] ≥ H[i - 1] - 1(去掉了原来的第一个,其他前缀一样相等)，所以Suffix[i]和在它前一名的后缀的最长公共前缀至少是H[i - 1] - 1。
int s[maxn];
int sa[maxn];
int t1[maxn],t2[maxn],c[maxn];
int Rank[maxn],height[maxn];
void construct_sa(int s[],int n,int m)//s，n为原串长度+1,（后面放个特殊字符），m是不同字符个数
{
    int i,j,p,*x=t1,*y=t2;
    for(i=0;i<m;i++)c[i]=0;
    for(i=0;i<n;i++)c[x[i]=s[i]]++;
    for(i=1;i<m;i++)c[i]+=c[i-1];
    for(i=n-1;i>=0;i--)sa[--c[x[i]]]=i;
    for(j=1;j<=n;j<<=1)
    {
        p=0;
        for(i=n-j;i<n;i++)y[p++]=i;
        for(i=0;i<n;i++)if(sa[i]>=j)y[p++]=sa[i]-j;
        for(i=0;i<m;i++)c[i]=0;
        for(i=0;i<n;i++)c[x[y[i]]]++;
        for(i=1;i<m;i++)c[i]+=c[i-1];
        for(i=n-1;i>=0;i--)sa[--c[x[y[i]]]]=y[i];
        swap(x,y);
        p=1;x[sa[0]]=0;
        for(i=1;i<n;i++)
            x[sa[i]]=y[sa[i-1]]==y[sa[i]] && y[sa[i-1]+j]==y[sa[i]+j]?p-1:p++;
        if(p>=n)break;
        m=p;
    }
}
void construct_lcp(int s[],int n)//s是原串,n是长度
{
    int k=0;
    for(int i=0;i<=n;i++)Rank[sa[i]]=i;
    for(int i=0;i<n;i++)
    {
        if(k)k--;
        int j=sa[Rank[i]-1];
        while(s[i+k]==s[j+k])k++;
        height[Rank[i]]=k;
    }
}
